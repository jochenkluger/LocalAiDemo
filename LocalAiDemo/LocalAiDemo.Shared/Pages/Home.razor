@page "/"
@using LocalAiDemo.Shared.Services
@using LocalAiDemo.Shared.Models
@using LocalAiDemo.Shared.Components
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@inject IFormFactor FormFactor 
@inject IAiAssistantService AiAssistant
@inject IMeasurementService MeasurementService
@inject IChatDatabaseService ChatDatabase
@inject IChatService ChatService
@inject IEmbeddingService EmbeddingService
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntimeForTts 
@inject ITtsService TtsService
@implements IDisposable

<PageTitle>Chat Demo</PageTitle>
<link rel="stylesheet" href="_content/LocalAiDemo.Shared/chat.css" />
<link rel="stylesheet" href="_content/LocalAiDemo.Shared/modal.css" />

<div class="chat-container">
    <!-- Left Column - Chat List -->
    <div class="chat-list">
        <h2>Chats</h2>
        <div class="search-box">
            <input type="text" placeholder="Suche..." @bind="searchQuery" @bind:event="oninput" @onkeyup="SearchChats" />
        </div>
        <div class="chat-items">
            @foreach (var chat in displayedChats)
            {
                <div class="chat-item @(chat.Id == selectedChatId ? "active" : "")" @onclick="() => SelectChat(chat.Id)">
                    <div class="person-avatar small">
                        @if (chat.Person != null && !string.IsNullOrEmpty(chat.Person.AvatarUrl))
                        {
                            <img src="@chat.Person.AvatarUrl" alt="@chat.Person.Name" />
                        }
                        else
                        {
                            <div class="avatar-placeholder">
                                @(chat.Person?.Name.FirstOrDefault() ?? 'U')
                            </div>
                        }
                        <span class="status-indicator @(chat.Person?.Status?.ToLower() ?? "offline")"></span>
                    </div>
                    <div class="chat-details">
                        <div class="chat-title">@(chat.Person?.Name ?? chat.Title)</div>
                        <div class="chat-preview">@GetChatPreview(chat)</div>
                        <div class="chat-time">@FormatTime(chat.CreatedAt)</div>
                    </div>
                </div>
            }

            @if (!displayedChats.Any())
            {
                <div class="empty-state">
                    <p>Keine Chats gefunden.</p>
                </div>
            }
        </div>
        <div class="new-chat-button">
            <button @onclick="@(async () => await ShowPersonSelectModal())">Neuer Chat</button>
        </div>
    </div>
    <!-- Middle Column - Current Chat -->
    <div class="current-chat">
        <ChatView 
            @ref="chatViewComponent" 
            CurrentChat="@selectedChat" 
            OnChatUpdated="@HandleChatUpdated" />
    </div>
    <!-- Right Column - AI Assistant -->
    <div class="ai-assistant">
        <h2>KI-Assistent</h2>
        <div class="assistant-content">
            <div class="assistant-chat-history">
                <div class="assistant-messages">
                    @foreach (var message in assistantChat.Messages)
                    {
                        <div class="message-preview @(message.IsUser ? "user" : "ai")">
                            <div class="message-content">@message.Content</div>
                            <div class="message-time">@FormatTime(message.Timestamp)</div>
                        </div>
                    }
                </div>
            </div>            <div class="assistant-actions">
                <button id="speechButton" class="action-button voice-record-button @(isRecording ? "recording" : "")" 
                        @onmousedown="StartRecording" @onmouseup="StopRecording" @onmouseleave="StopRecording">
                    <i class="bi bi-mic"></i> @(isRecording ? "Aufnahme läuft..." : "Sprechen (Halten)")
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Status Bar for Measurements -->
<div class="status-bar">
    @foreach (var measurement in measurements)
    {
        <div class="status-item">
            <i class="@GetIconForMeasurement(measurement.Name)"></i>
            @measurement.Name: @Math.Round(measurement.Value, 1)@measurement.Unit
        </div>
    }
</div>

<!-- Person Select Modal -->
<PersonSelectModal @ref="personSelectModal"
                   Persons="availablePersons"
                   OnPersonSelected="OnPersonSelected"
                   OnCancelled="OnModalCancelled" />

@code {
    private string factor => FormFactor.GetFormFactor();
    private string platform => FormFactor.GetPlatform();
    private PersonSelectModal? personSelectModal;
    private ChatView? chatViewComponent;
    private string searchQuery = "";

    // Database-backed data
    private List<Chat> chats = new List<Chat>();
    private List<Chat> displayedChats = new List<Chat>();
    private List<Person> availablePersons = new List<Person>();
    
    // Eigener Chat für den Assistenten
    private Chat assistantChat = new Chat 
    { 
        Id = -1, 
        Title = "KI-Assistent Chat",
        CreatedAt = DateTime.Now,
        IsActive = true,
        Messages = new List<ChatMessage>
        {
            new ChatMessage
            {
                Id = 1,
                Content = "Hallo, ich bin der KI-Assistent. Wie kann ich behilflich sein?",
                Timestamp = DateTime.Now,
                IsUser = false
            }
        }
    };
    
    // Measurements from service
    private List<Measurement> measurements = new List<Measurement>();
    private int selectedChatId = 0;
    private Chat? selectedChat => chats.FirstOrDefault(c => c.Id == selectedChatId);  // Keep as computed property for consistency
    
    // Sprachaufnahme-Variablen
    private bool isRecording = false;
    private bool isSpeaking = false;
    private string recordedText = "";
    private IJSRuntime? jsRuntime;
    private DotNetObjectReference<Home>? objRef;

    // JavaScript-Injection für Sprachaufnahme
    [Inject]
    public IJSRuntime JSRuntime { 
        get => jsRuntime ?? throw new InvalidOperationException("JSRuntime was not initialized");
        set => jsRuntime = value;
    }    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Speech Recognition initialisieren
                Logger.LogInformation("Loading speech recognition script");
                await JSRuntime.InvokeVoidAsync("eval", 
                    "if (!document.getElementById('speech-recognition-js')) {" +
                    "  var script = document.createElement('script');" +
                    "  script.id = 'speech-recognition-js';" +
                    "  script.src = '_content/LocalAiDemo.Shared/speech-recognition.js';" +
                    "  script.async = true;" +
                    "  script.onload = function() { console.log('Speech recognition script loaded successfully'); };" +
                    "  script.onerror = function() { console.error('Failed to load speech recognition script'); };" +
                    "  document.body.appendChild(script);" +
                    "}");
                
                // TTS-Funktionen direkt definieren falls das Laden des Skripts fehlschlägt
                Logger.LogInformation("Defining inline TTS functions");
                await JSRuntimeForTts.InvokeVoidAsync("eval", @"
                    // Definiere TTS-Funktionen direkt im Window-Objekt
                    window.speechSynthesis = window.speechSynthesis || {};
                    window.ttsVoices = [];
                    window.currentUtterance = null;

                    // TTS-Initialisierungsfunktion
                    window.initBrowserTts = function() {
                        try {
                            if ('speechSynthesis' in window) {
                                // Abrufen der verfügbaren Stimmen
                                window.ttsVoices = window.speechSynthesis.getVoices();
                                
                                // In Chrome werden die Stimmen asynchron geladen
                                if (window.ttsVoices.length === 0) {
                                    window.speechSynthesis.addEventListener('voiceschanged', function() {
                                        window.ttsVoices = window.speechSynthesis.getVoices();
                                        console.log('TTS: Geladen ' + window.ttsVoices.length + ' Stimmen');
                                    });
                                } else {
                                    console.log('TTS: Geladen ' + window.ttsVoices.length + ' Stimmen');
                                }
                                
                                console.log('Browser TTS erfolgreich initialisiert');
                                return true;
                            } else {
                                console.error('Keine Browser TTS-Unterstützung verfügbar');
                                return false;
                            }
                        } catch (error) {
                            console.error('Fehler bei der Initialisierung von Browser TTS:', error);
                            return false;
                        }
                    };

                    // Text vorlesen Funktion
                    window.speakText = function(text) {
                        try {
                            if (!('speechSynthesis' in window)) {
                                console.error('TTS ist nicht verfügbar');
                                return false;
                            }
                            
                            // Stoppe aktuelle Sprache, falls vorhanden
                            if (window.currentUtterance) {
                                window.stopSpeaking();
                            }
                            
                            // Erstelle neue Äußerung
                            var utterance = new SpeechSynthesisUtterance(text);
                            window.currentUtterance = utterance;
                            
                            // Finde deutsche Stimme, falls verfügbar
                            var voices = window.speechSynthesis.getVoices();
                            var germanVoice = voices.find(function(voice) {
                                return voice.lang.startsWith('de') && voice.localService;
                            });
                            
                            // Alternativ verwende die erste deutsche Stimme
                            var anyGermanVoice = voices.find(function(voice) {
                                return voice.lang.startsWith('de');
                            });
                            
                            // Setze Stimme, wenn verfügbar
                            if (germanVoice) {
                                utterance.voice = germanVoice;
                                console.log('TTS: Verwende lokale deutsche Stimme: ' + germanVoice.name);
                            } else if (anyGermanVoice) {
                                utterance.voice = anyGermanVoice;
                                console.log('TTS: Verwende deutsche Stimme: ' + anyGermanVoice.name);
                            } else {
                                console.log('TTS: Keine deutsche Stimme gefunden, verwende Standard-Stimme');
                            }
                            
                            // Setze die Sprache auf Deutsch
                            utterance.lang = 'de-DE';
                            
                            // Setze Ereignisbehandlung
                            utterance.onend = function() {
                                console.log('TTS: Sprechen beendet');
                                window.currentUtterance = null;
                            };
                            
                            utterance.onerror = function(event) {
                                console.error('TTS Fehler:', event.error);
                                window.currentUtterance = null;
                            };
                            
                            // Starte das Sprechen
                            window.speechSynthesis.speak(utterance);
                            console.log('TTS: Spreche Text: ' + text);
                            
                            return true;
                        } catch (error) {
                            console.error('Fehler beim Sprechen:', error);
                            return false;
                        }
                    };

                    // Stoppe die Sprachausgabe
                    window.stopSpeaking = function() {
                        try {
                            if (window.speechSynthesis) {
                                window.speechSynthesis.cancel();
                                window.currentUtterance = null;
                                console.log('TTS: Sprachausgabe gestoppt');
                                return true;
                            }
                        } catch (error) {
                            console.error('Fehler beim Stoppen der Sprachausgabe:', error);
                        }
                        return false;
                    };
                ");
                
                // Auch den externen TTS-Script laden (als Backup)
                Logger.LogInformation("Loading browser TTS script as backup");
                await JSRuntimeForTts.InvokeVoidAsync("eval", 
                    "if (!document.getElementById('browser-tts-js')) {" +
                    "  var script = document.createElement('script');" +
                    "  script.id = 'browser-tts-js';" +
                    "  script.src = '_content/LocalAiDemo.Shared/browser-tts.js';" +
                    "  script.async = true;" +
                    "  script.onload = function() { " +
                    "    console.log('Browser TTS script loaded successfully'); " +
                    "  };" +
                    "  script.onerror = function() { console.error('Failed to load Browser TTS script'); };" +
                    "  document.body.appendChild(script);" +
                    "}");
                
                // Short delay to ensure script is loaded
                await Task.Delay(1000);
                
                // Create our object reference
                objRef = DotNetObjectReference.Create(this);
                
                // Initialize speech recognition with our object reference
                Logger.LogInformation("Initializing speech recognition");
                await JSRuntime.InvokeVoidAsync("initSpeechRecognition", objRef);
                Logger.LogInformation("Speech recognition initialized");
                
                // TTS direkt initialisieren
                try {
                    Logger.LogInformation("Explicitly initializing browser TTS");
                    await JSRuntimeForTts.InvokeVoidAsync("initBrowserTts");
                    Logger.LogInformation("Browser TTS initialized");
                    
                    // Test, ob speakText definiert ist
                    var speakTextDefined = await JSRuntimeForTts.InvokeAsync<bool>("eval", 
                        "typeof window.speakText === 'function'");
                    Logger.LogInformation("speakText function is " + (speakTextDefined ? "defined" : "NOT defined"));
                }
                catch (Exception ex) {
                    Logger.LogError(ex, "Error initializing Browser TTS: {ErrorMessage}", ex.Message);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing scripts: {ErrorMessage}", ex.Message);
            }
        }
    }
    
    private async Task StartRecording()
    {
        try
        {
            Logger.LogInformation("Starte Sprachaufnahme");
            isRecording = true;
            await JSRuntime.InvokeVoidAsync("startSpeechRecognition");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Starten der Sprachaufnahme: {ErrorMessage}", ex.Message);
        }
    }

    private async Task StopRecording()
    {
        try
        {
            if (!isRecording) return;
            
            Logger.LogInformation("Stoppe Sprachaufnahme");
            isRecording = false;
            await JSRuntime.InvokeVoidAsync("stopSpeechRecognition");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Stoppen der Sprachaufnahme: {ErrorMessage}", ex.Message);
        }
    }
    
    [JSInvokable]
    public async Task OnSpeechRecognized(string text)
    {
        try
        {
            Logger.LogInformation("Spracherkennung erfolgreich: {Text}", text);
            recordedText = text;
            
            if (!string.IsNullOrWhiteSpace(recordedText))
            {
                // Füge die Benutzer-Nachricht zum Assistenten-Chat hinzu
                var userMessage = new ChatMessage
                {
                    Id = assistantChat.Messages.Count > 0 ? assistantChat.Messages.Max(m => m.Id) + 1 : 1,
                    Content = recordedText,
                    Timestamp = DateTime.Now,
                    IsUser = true
                };
                assistantChat.Messages.Add(userMessage);
                
                // Generiere eine Antwort vom Assistenten
                string assistantResponse = await AiAssistant.GetResponseAsync(recordedText);
                
                // Füge die Assistenten-Antwort hinzu
                var assistantMessage = new ChatMessage
                {
                    Id = assistantChat.Messages.Count > 0 ? assistantChat.Messages.Max(m => m.Id) + 1 : 1,
                    Content = assistantResponse,
                    Timestamp = DateTime.Now,
                    IsUser = false
                };
                assistantChat.Messages.Add(assistantMessage);
                
                // Spreche die Antwort mit TTS
                await SpeakAssistantResponse(assistantResponse);
                
                // Wenn auch ein regulärer Chat ausgewählt ist, senden wir die Nachricht auch dorthin
                if (selectedChat != null && chatViewComponent != null)
                {
                    await chatViewComponent.SendMessageExternally(recordedText);
                }
                
                // UI aktualisieren
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler bei der Verarbeitung der erkannten Sprache: {ErrorMessage}", ex.Message);
        }
    }      private async Task SpeakAssistantResponse(string response)
    {
        try
        {
            Logger.LogInformation("Spreche Assistenten-Antwort mit TTS: {ResponseLength} Zeichen", response.Length);
            
            // UI-Status aktualisieren
            isSpeaking = true;
            StateHasChanged();
            
            // Verwende den injizierten TTS-Service
            if (TtsService != null)
            {
                try
                {
                    await TtsService.SpeakAsync(response);
                    Logger.LogInformation("TTS erfolgreich gestartet für {Length} Zeichen", response.Length);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Fehler beim Sprechen mit TTS-Service: {ErrorMessage}", ex.Message);
                    
                    // Fallback zum Browser-TTS wenn der Service fehlschlägt
                    if (JSRuntimeForTts != null)
                    {
                        Logger.LogWarning("Verwende Browser-TTS als Fallback");
                        await JSRuntimeForTts.InvokeVoidAsync("eval", @"                            try {
                                if ('speechSynthesis' in window) {
                                    window.speechSynthesis.cancel();
                                    var u = new SpeechSynthesisUtterance('" + response.Replace("'", "\\'").Replace("\n", " ") + @"');
                                    u.lang = 'de-DE';
                                    window.speechSynthesis.speak(u);
                                    console.log('Fallback TTS ausgeführt');
                                }
                            } catch (e) { 
                                console.error('Fallback TTS fehlgeschlagen:', e); 
                            }
                        ");
                    }
                }
            }
            else if (JSRuntimeForTts != null)
            {
                // Fallback zum Browser-TTS wenn kein TTS-Service verfügbar ist
                Logger.LogWarning("Kein TTS-Service verfügbar, verwende Browser-TTS");
                await JSRuntimeForTts.InvokeVoidAsync("eval", @"
                    try {
                        if ('speechSynthesis' in window) {
                            window.speechSynthesis.cancel();
                            var u = new SpeechSynthesisUtterance('" + response.Replace("'", "\\'").Replace("\n", " ") + @"');
                            u.lang = 'de-DE';
                            window.speechSynthesis.speak(u);
                            console.log('Fallback TTS ausgeführt');
                        }
                    } catch (e) { 
                        console.error('Fallback TTS fehlgeschlagen:', e); 
                    }
                ");
            }
            else
            {
                Logger.LogWarning("Weder TTS-Service noch JSRuntime verfügbar für TTS");
            }
            
            // UI-Status zurücksetzen (mit Verzögerung)
            await Task.Delay(Math.Min(3000, response.Length * 40)); // ~40ms pro Zeichen, max 3 Sekunden
            isSpeaking = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Sprechen der Assistenten-Antwort: {ErrorMessage}", ex.Message);
            isSpeaking = false;
            StateHasChanged();
        }
    }    private async Task StopTts()
    {
        try
        {
            if (isSpeaking)
            {
                // Versuche zuerst den TTS-Service zu verwenden
                if (TtsService != null)
                {
                    try
                    {
                        await TtsService.StopSpeakingAsync();
                        Logger.LogInformation("TTS-Ausgabe über Service gestoppt");
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning("Fehler beim Stoppen der TTS über Service: {Error}, versuche Fallback", ex.Message);
                        
                        // Fallback zum Browser TTS
                        if (JSRuntimeForTts != null)
                        {
                            await JSRuntimeForTts.InvokeVoidAsync("eval", "if('speechSynthesis' in window) window.speechSynthesis.cancel();");
                            Logger.LogInformation("TTS-Ausgabe über Browser gestoppt");
                        }
                    }
                }
                // Fallback zum Browser wenn kein Service verfügbar
                else if (JSRuntimeForTts != null)
                {
                    await JSRuntimeForTts.InvokeVoidAsync("eval", "if('speechSynthesis' in window) window.speechSynthesis.cancel();");
                    Logger.LogInformation("TTS-Ausgabe über Browser gestoppt");
                }
                
                isSpeaking = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Stoppen der TTS-Ausgabe: {ErrorMessage}", ex.Message);
        }
    }
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            Logger.LogDebug("Home.OnInitializedAsync starting");

            // Initialize the database
            Logger.LogDebug("Initializing database...");
            await ChatDatabase.InitializeDatabaseAsync();
            Logger.LogDebug("Database initialized");

            // Load chats
            Logger.LogDebug("Loading chats...");
            chats = await ChatDatabase.GetAllChatsAsync();
            displayedChats = chats.ToList();
            Logger.LogDebug("Loaded {ChatCount} chats", chats.Count);

            // Load available persons
            Logger.LogDebug("Loading persons...");
            availablePersons = await ChatDatabase.GetAllPersonsAsync();
            Logger.LogDebug("Loaded {PersonCount} persons", availablePersons.Count);

            // Select the first chat if available
            if (chats.Any())
            {
                selectedChatId = chats.First().Id;
                Logger.LogDebug("Selected chat ID: {ChatId}", selectedChatId);
            }

            // Get initial measurements
            Logger.LogDebug("Getting initial measurements...");
            measurements = MeasurementService.GetMeasurements();
            Logger.LogDebug("Found {MeasurementCount} measurements", measurements.Count);

            // Log measurements
            foreach (var m in measurements)
            {
                Logger.LogDebug("Measurement: {Name}={Value}{Unit}", m.Name, m.Value.ToString("F1"), m.Unit);
            }

            // Subscribe to measurement updates
            Logger.LogDebug("Subscribing to measurement updates");
            MeasurementService.MeasurementsUpdated += OnMeasurementsUpdated;
            Logger.LogDebug("Home.OnInitializedAsync completed");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in OnInitializedAsync: {ErrorMessage}", ex.Message);
        }
    }
    
    public void Dispose()
    {
        try
        {
            // Unsubscribe from events when component is disposed
            MeasurementService.MeasurementsUpdated -= OnMeasurementsUpdated;
            
            // Stop active TTS
            if (isSpeaking)
            {
                StopTts().ConfigureAwait(false);
            }
            
            // Clean up JS object reference
            objRef?.Dispose();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler in Dispose-Methode: {ErrorMessage}", ex.Message);
        }
    }
    
    private void OnMeasurementsUpdated(object? sender, List<Measurement> updatedMeasurements)
    {
        if (updatedMeasurements == null || updatedMeasurements.Count == 0)
        {
            Logger.LogDebug("Received empty measurements update");
            return;
        }
        
        // Update measurements with the newest data
        measurements = updatedMeasurements;
        
        // Log the new measurements
        foreach (var m in measurements)
        {
            Logger.LogDebug("Updated measurement: {Name}={Value}{Unit}", m.Name, m.Value.ToString("F1"), m.Unit);
        }
        
        // Update UI
        InvokeAsync(StateHasChanged);
    }
    
    private async Task SelectChat(int chatId)
    {
        try
        {
            Logger.LogInformation("SelectChat called with chatId={ChatId}", chatId);
            
            if (chatId <= 0)
            {
                Logger.LogWarning("Invalid chatId: {ChatId}", chatId);
                return;
            }
            
            selectedChatId = chatId;
            
            // Make sure we have the latest data
            Chat? chat = null;
            try
            {
                chat = await ChatDatabase.GetChatAsync(chatId);
                if (chat == null)
                {
                    Logger.LogWarning("ChatDatabase.GetChatAsync({ChatId}) returned null", chatId);
                    
                    // Try to use the ChatService as a fallback
                    chat = await ChatService.GetChatAsync(chatId);
                    if (chat == null)
                    {
                        Logger.LogWarning("ChatService.GetChatAsync({ChatId}) also returned null", chatId);
                    }
                    else
                    {
                        Logger.LogInformation("Retrieved chat from ChatService: {ChatId}", chat.Id);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error retrieving chat {ChatId}: {ErrorMessage}", chatId, ex.Message);
            }
            
            if (chat != null)
            {
                Logger.LogInformation("Retrieved chat: id={ChatId}, Title={Title}, Messages={Count}", 
                    chat.Id, chat.Title, chat.Messages.Count);
                    
                // Update the chat in our list
                var index = chats.FindIndex(c => c.Id == chatId);
                if (index >= 0)
                {
                    chats[index] = chat;
                    Logger.LogInformation("Updated chat in list at index {Index}", index);
                }
                else
                {
                    Logger.LogWarning("Chat {ChatId} not found in chat list!", chatId);
                    // Add it to the list as it should be there
                    chats.Insert(0, chat);
                    Logger.LogInformation("Added chat to list");
                }
                
                // Force UI update
                await InvokeAsync(StateHasChanged);
                Logger.LogInformation("UI updated after chat selection");
                
                // Force UI update for the ChatView component
                Logger.LogInformation("Forcing UI update for ChatView");
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                Logger.LogWarning("Selected chat {ChatId} not found in database", chatId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in SelectChat: {ErrorMessage}", ex.Message);
        }
    }
    
    private async Task ShowPersonSelectModal()
    {
        // Reload persons list before showing the modal
        Logger.LogDebug("Reloading persons before showing modal");
        try
        {
            availablePersons = await ChatDatabase.GetAllPersonsAsync();
            Logger.LogDebug("Reloaded {PersonCount} persons", availablePersons.Count);

            if (availablePersons.Count == 0)
            {
                Logger.LogDebug("No persons found, attempting to reinitialize database");
                await ChatDatabase.InitializeDatabaseAsync();
                availablePersons = await ChatDatabase.GetAllPersonsAsync();
                Logger.LogDebug("After reinitialization: {PersonCount} persons", availablePersons.Count);
            }
            
            // Make sure the modal exists
            if (personSelectModal == null)
            {
                Logger.LogWarning("personSelectModal is null!");
                return;
            }
            
            // Show the modal
            Logger.LogDebug("Showing person select modal");
            personSelectModal.Show();
            
            // Force UI update
            StateHasChanged();
            
            Logger.LogDebug("Modal should now be visible");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in ShowPersonSelectModal: {ErrorMessage}", ex.Message);
        }
    }
    
    private async Task OnPersonSelected(Person person)
    {
        try
        {
            Logger.LogInformation("Home.OnPersonSelected - Called with person: {PersonName} (ID: {PersonId})", 
                person?.Name ?? "null", person?.Id ?? 0);
            
            if (person == null)
            {
                Logger.LogError("Home.OnPersonSelected - Received null person!");
                return;
            }
            
            // Log the ChatService instance to see if it's properly injected
            if (ChatService == null)
            {
                Logger.LogError("ChatService is null! Service was not injected properly.");
                
                // Fall back to direct creation if ChatService is not available
                Logger.LogInformation("Falling back to direct chat creation");
                var newChat = new Chat
                {
                    Title = $"Chat with {person.Name}",
                    CreatedAt = DateTime.Now,
                    IsActive = true,
                    PersonId = person.Id,
                    Person = person,
                    Messages = new List<ChatMessage>()
                };
                
                // Add the first message
                var firstMessage = new ChatMessage
                {
                    Content = $"Hallo, ich bin {person.Name} vom {person.Department}. Wie kann ich dir helfen?",
                    Timestamp = DateTime.Now,
                    IsUser = false
                };
                newChat.Messages.Add(firstMessage);
                
                try
                {
                    // Save using ChatDatabase directly
                    var chatId = await ChatDatabase.SaveChatAsync(newChat);
                    newChat.Id = chatId;
                    
                    chats.Insert(0, newChat);
                    displayedChats = new List<Chat>(chats);
                    
                    selectedChatId = chatId;
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error in fallback chat creation: {ErrorMessage}", ex.Message);
                }
                
                return;
            }
            
            Logger.LogInformation("Creating new chat with person {PersonId} ({PersonName})", person.Id, person.Name);
            
            try 
            {
                // Use ChatService to create a new chat with the selected person
                var newChat = await ChatService.CreateNewChatAsync(person);
                
                if (newChat == null)
                {
                    Logger.LogError("ChatService.CreateNewChatAsync returned null!");
                    return;
                }
                
                Logger.LogInformation("New chat created with ID: {ChatId}", newChat.Id);
                
                if (newChat.Id == 0)
                {
                    Logger.LogWarning("New chat has ID=0, which may indicate it wasn't saved correctly");
                }
                
                // Add to our list and select it
                chats.Insert(0, newChat);
                displayedChats = new List<Chat>(chats);
                
                // Set the selectedChatId directly
                selectedChatId = newChat.Id;
                
                // Force UI update first
                await InvokeAsync(StateHasChanged);
                
                // Then use SelectChat to refresh the UI with the new chat
                Logger.LogInformation("Selecting chat with ID: {ChatId}", newChat.Id);
                await SelectChat(newChat.Id);
                
                Logger.LogInformation("UI updated with new chat");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error creating chat with ChatService: {ErrorMessage}", ex.Message);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Overall error in OnPersonSelected: {ErrorMessage}", ex.Message);
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OnModalCancelled()
    {
        // Nothing to do
    }

    private void SearchChats()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            displayedChats = chats.ToList();
        }
        else
        {
            var query = searchQuery.ToLower();
            displayedChats = chats
                .Where(c =>
                    (c.Title?.ToLower().Contains(query) ?? false) ||
                    (c.Person?.Name.ToLower().Contains(query) ?? false) ||
                    c.Messages.Any(m => m.Content.ToLower().Contains(query)))
                .ToList();
        }
    }

    private string GetChatPreview(Chat chat)
    {
        var lastMessage = chat.Messages.OrderByDescending(m => m.Timestamp).FirstOrDefault();
        return lastMessage?.Content ?? "";
    }

    // Helper method to format timestamps for display
    private string FormatTime(DateTime time)
    {
        if (time.Date == DateTime.Now.Date)
        {
            return time.ToString("HH:mm");
        }
        else if (time.Date == DateTime.Now.Date.AddDays(-1))
        {
            return "Gestern";
        }
        else
        {
            return time.ToString("dd.MM.yyyy");
        }
    }

    private string GetIconForCapability(string capability)
    {
        return capability switch
        {
            "Textgenerierung" => "bi bi-chat-dots",
            "Übersetzung" => "bi bi-translate",
            "Informationen" => "bi bi-lightbulb",
            "Code-Hilfe" => "bi bi-code-square",
            _ => "bi bi-gear"
        };
    }

    private string GetIconForMeasurement(string measurementName)
    {
        return measurementName switch
        {
            "CPU-Auslastung" => "bi bi-cpu",
            "Speichernutzung" => "bi bi-memory",
            "Netzwerkverkehr" => "bi bi-speedometer",
            "Latenz" => "bi bi-clock",
            "Temperatur" => "bi bi-thermometer-half",
            _ => "bi bi-graph-up"
        };
    }

    // Handle chat updates from ChatView component
    private async Task HandleChatUpdated(Chat updatedChat)
    {
        Logger.LogInformation("HandleChatUpdated called with chat: {ChatId}", updatedChat.Id);
        
        // Update the chat in our list
        var index = chats.FindIndex(c => c.Id == updatedChat.Id);
        if (index >= 0)
        {
            chats[index] = updatedChat;
            Logger.LogInformation("Updated chat in list at index {Index}", index);
        }
        
        // Make sure displayedChats is updated too (in case of search filtering)
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            displayedChats = chats.ToList();
        }
        else
        {
            SearchChats();
        }
        
        // Force UI update
        await InvokeAsync(StateHasChanged);
    }
}
