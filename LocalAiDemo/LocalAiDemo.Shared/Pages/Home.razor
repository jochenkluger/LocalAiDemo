@page "/"
@using LocalAiDemo.Shared.Components
@using LocalAiDemo.Shared.Models
@using LocalAiDemo.Shared.Services
@using LocalAiDemo.Shared.Services.Generation
@using LocalAiDemo.Shared.Services.Search
@using LocalAiDemo.Shared.Services.Tts
@using LocalAiDemo.Shared.Services.Sst
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@inject IFormFactor FormFactor 
@inject IAiAssistantService AiAssistant
@inject IMeasurementService MeasurementService
@inject IChatDatabaseService ChatDatabase
@inject IChatService ChatService
@inject IEmbeddingService EmbeddingService
@inject IMessageInjectionService MessageInjection
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntimeForTts 
@inject IJSRuntime JSRuntimeForSst
@inject ITextGenerationService TextGenerationService
@inject ITtsService TtsService
@inject ISstService SstService
@implements IDisposable

<PageTitle>Chat Demo</PageTitle>
<link rel="stylesheet" href="_content/LocalAiDemo.Shared/chat.css" />
<link rel="stylesheet" href="_content/LocalAiDemo.Shared/modal.css" />

<div class="chat-container">
    <!-- Left Column - Chat List -->
    <div class="chat-list">
        <h2>Chats</h2>        <div class="search-box">
            <div class="search-input-group">
                <input type="text" 
                       placeholder="Intelligente Suche in allen Chats..." 
                       @bind="searchQuery" 
                       @onkeypress="HandleSearchKeyPress" />
                <button class="btn btn-sm btn-primary" @onclick="PerformVectorSearch" disabled="@isSearching">
                    @if (isSearching)
                    {
                        <span class="spinner-border spinner-border-sm" role="status"></span>
                    }
                    else
                    {
                        <i class="bi bi-search"></i>
                    }
                    Suchen
                </button>
            </div>
        </div>        <div class="chat-items">
            @if (searchResults.Any())
            {
                <!-- Search Results -->
                <div class="search-results-header">
                    <span>@searchResults.Count Suchergebnisse</span>
                    <button class="btn btn-sm btn-link" @onclick="ClearSearchResults">
                        <i class="bi bi-x"></i> Zurück
                    </button>
                </div>
                @foreach (var result in searchResults)
                {
                    <div class="search-result-item" @onclick="() => NavigateToSearchResult(result)">                        <div class="search-result-header">
                            <div class="person-avatar small">
                                @if (result.Chat?.Contact != null && !string.IsNullOrEmpty(result.Chat.Contact.AvatarUrl))
                                {
                                    <img src="@result.Chat.Contact.AvatarUrl" alt="@result.Chat.Contact.Name" />
                                }
                                else
                                {
                                    <div class="avatar-placeholder">
                                        @(result.Chat?.Contact?.Name?.FirstOrDefault() ?? 'U')
                                    </div>
                                }
                            </div>
                            <div class="search-result-info">
                                <div class="chat-title">@(result.Chat?.Contact?.Name ?? result.Chat?.Title ?? "Unbekannter Chat")</div>
                                <div class="result-date">@result.Segment.SegmentDate.ToString("dd.MM.yyyy")</div>
                                <div class="result-score">Relevanz: @(Math.Round(result.SimilarityScore * 100, 1))%</div>
                            </div>
                        </div>
                        <div class="result-content">@result.HighlightedSnippet</div>
                    </div>
                }
            }
            else
            {
                <!-- Normal Chat List -->
                @foreach (var chat in displayedChats)
                {                    <div class="chat-item @(chat.Id == selectedChatId ? "active" : "")" @onclick="() => SelectChat(chat.Id)">
                        <div class="person-avatar small">
                            @if (chat.Contact != null && !string.IsNullOrEmpty(chat.Contact.AvatarUrl))
                            {
                                <img src="@chat.Contact.AvatarUrl" alt="@chat.Contact.Name" />
                            }
                            else
                            {
                                <div class="avatar-placeholder">
                                    @(chat.Contact?.Name?.FirstOrDefault() ?? 'U')
                                </div>
                            }
                            <span class="status-indicator @(chat.Contact?.Status.ToString().ToLower() ?? "offline")"></span>
                        </div>
                        <div class="chat-details">
                            <div class="chat-title">@(chat.Contact?.Name ?? chat.Title)</div>
                            <div class="chat-preview">@GetChatPreview(chat)</div>
                            <div class="chat-time">@FormatTime(chat.CreatedAt)</div>
                        </div>
                    </div>
                }

                @if (!displayedChats.Any())
                {
                    <div class="empty-state">
                        <p>Keine Chats gefunden.</p>
                    </div>
                }
            }
        </div>
        <div class="new-chat-button">
            <button @onclick="@(async () => await ShowContactSelectModal())">Neuer Chat</button>
        </div>
    </div>
    <!-- Middle Column - Current Chat -->
    <div class="current-chat">        <ChatView 
            @ref="chatViewComponent" 
            CurrentChat="@selectedChat" 
            OnChatUpdated="@HandleChatUpdated"
            OnNavigateToChat="@HandleNavigateToChat" /></div>
    <!-- Right Column - AI Assistant -->
    <div class="ai-assistant">
        <h2>KI-Assistent</h2>
        <div class="assistant-content">
            @if (isTextGenerationInitializing)
            {
                <div class="ai-initialization-progress">
                    <div class="progress-header">
                        <i class="bi bi-cpu"></i>
                        <span>@textGenerationStatus</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-ai">
                            <div class="progress-fill-ai" style="width: @textGenerationProgress%"></div>
                        </div>
                        <span class="progress-percentage">@Math.Round(textGenerationProgress, 1)%</span>
                    </div>
                </div>
            }
            else if (!isTextGenerationInitialized)
            {
                <div class="ai-error-state">
                    <i class="bi bi-exclamation-triangle"></i>
                    <span>KI-Modell konnte nicht initialisiert werden</span>
                </div>
            }
            else
            {
                <div class="assistant-chat-history">
                    <div class="assistant-messages">
                        @foreach (var message in assistantChat.Messages)
                        {
                            <div class="message-preview @(message.IsUser ? "user" : "ai")">
                                <div class="message-content">@message.Content</div>
                                <div class="message-time">@FormatTime(message.Timestamp)</div>
                            </div>
                        }
                    </div>
                </div>            
                <div class="assistant-actions">
                    <button id="speechButton" class="action-button voice-record-button @(isRecording ? "recording" : "")" 
                            @onmousedown="StartRecording" @onmouseup="StopRecording" @onmouseleave="StopRecording">
                        <i class="bi bi-mic"></i> @(isRecording ? "Aufnahme läuft..." : "Sprechen (Halten)")
                    </button>
                </div>
            }
        </div>
    </div>
</div>

<!-- Status Bar for Measurements -->
<div class="status-bar">
    @foreach (var measurement in measurements)
    {
        <div class="status-item">
            <i class="@GetIconForMeasurement(measurement.Name)"></i>
            @measurement.Name: @Math.Round(measurement.Value, 1)@measurement.Unit
        </div>
    }
</div>

<!-- Contact Select Modal -->
<ContactSelectModal @ref="contactSelectModal"
                   OnContactSelected="OnContactSelected" />

@code {
    private string factor => FormFactor.GetFormFactor();
    private string platform => FormFactor.GetPlatform();    private ContactSelectModal? contactSelectModal;
    private ChatView? chatViewComponent;
    private string searchQuery = "";
    private bool isSearching = false;
    private List<ChatSegmentSearchResult> searchResults = new List<ChatSegmentSearchResult>();

    // Database-backed data
    private List<Chat> chats = new List<Chat>();
    private List<Chat> displayedChats = new List<Chat>();
    private List<Contact> availableContacts = new List<Contact>();
      // Eigener Chat für den Assistenten
    private Chat assistantChat = new Chat 
    { 
        Id = -1, 
        Title = "KI-Assistent Chat",
        CreatedAt = DateTime.Now,
        IsActive = true,
        Messages = new List<ChatMessage>()
    };
    
    // Measurements from service
    private List<Measurement> measurements = new List<Measurement>();
    private int selectedChatId = 0;
    private Chat? selectedChat => chats.FirstOrDefault(c => c.Id == selectedChatId);  // Keep as computed property for consistency
    
    // Text Generation Service Initialisierung
    private bool isTextGenerationInitialized = false;
    private bool isTextGenerationInitializing = false;
    private double textGenerationProgress = 0;
    private string textGenerationStatus = "";
    
    // Sprachaufnahme-Variablen
    private bool isRecording = false;
    private bool isSpeaking = false;
    private string recordedText = "";
    private IJSRuntime? jsRuntime;
    private DotNetObjectReference<Home>? objRef;

    // JavaScript-Injection für Sprachaufnahme
    [Inject]
    public IJSRuntime JSRuntime { 
        get => jsRuntime ?? throw new InvalidOperationException("JSRuntime was not initialized");
        set => jsRuntime = value;
    }    protected override async Task OnAfterRenderAsync(bool firstRender)
    {        if (firstRender)
        {
            try
            {
                // TTS-Funktionen direkt definieren falls das Laden des Skripts fehlschlägt
                Logger.LogInformation("Defining inline TTS functions");
                await JSRuntimeForTts.InvokeVoidAsync("eval", @"
                    // Definiere TTS-Funktionen direkt im Window-Objekt
                    window.speechSynthesis = window.speechSynthesis || {};
                    window.ttsVoices = [];
                    window.currentUtterance = null;

                    // TTS-Initialisierungsfunktion
                    window.initBrowserTts = function() {
                        try {
                            if ('speechSynthesis' in window) {
                                // Abrufen der verfügbaren Stimmen
                                window.ttsVoices = window.speechSynthesis.getVoices();
                                
                                // In Chrome werden die Stimmen asynchron geladen
                                if (window.ttsVoices.length === 0) {
                                    window.speechSynthesis.addEventListener('voiceschanged', function() {
                                        window.ttsVoices = window.speechSynthesis.getVoices();
                                        console.log('TTS: Geladen ' + window.ttsVoices.length + ' Stimmen');
                                    });
                                } else {
                                    console.log('TTS: Geladen ' + window.ttsVoices.length + ' Stimmen');
                                }
                                
                                console.log('Browser TTS erfolgreich initialisiert');
                                return true;
                            } else {
                                console.error('Keine Browser TTS-Unterstützung verfügbar');
                                return false;
                            }
                        } catch (error) {
                            console.error('Fehler bei der Initialisierung von Browser TTS:', error);
                            return false;
                        }
                    };

                    // Text vorlesen Funktion
                    window.speakText = function(text) {
                        try {
                            if (!('speechSynthesis' in window)) {
                                console.error('TTS ist nicht verfügbar');
                                return false;
                            }
                            
                            // Stoppe aktuelle Sprache, falls vorhanden
                            if (window.currentUtterance) {
                                window.stopSpeaking();
                            }
                            
                            // Erstelle neue Äußerung
                            var utterance = new SpeechSynthesisUtterance(text);
                            window.currentUtterance = utterance;
                            
                            // Finde deutsche Stimme, falls verfügbar
                            var voices = window.speechSynthesis.getVoices();
                            var germanVoice = voices.find(function(voice) {
                                return voice.lang.startsWith('de') && voice.localService;
                            });
                            
                            // Alternativ verwende die erste deutsche Stimme
                            var anyGermanVoice = voices.find(function(voice) {
                                return voice.lang.startsWith('de');
                            });
                            
                            // Setze Stimme, wenn verfügbar
                            if (germanVoice) {
                                utterance.voice = germanVoice;
                                console.log('TTS: Verwende lokale deutsche Stimme: ' + germanVoice.name);
                            } else if (anyGermanVoice) {
                                utterance.voice = anyGermanVoice;
                                console.log('TTS: Verwende deutsche Stimme: ' + anyGermanVoice.name);
                            } else {
                                console.log('TTS: Keine deutsche Stimme gefunden, verwende Standard-Stimme');
                            }
                            
                            // Setze die Sprache auf Deutsch
                            utterance.lang = 'de-DE';
                            
                            // Setze Ereignisbehandlung
                            utterance.onend = function() {
                                console.log('TTS: Sprechen beendet');
                                window.currentUtterance = null;
                            };
                            
                            utterance.onerror = function(event) {
                                console.error('TTS Fehler:', event.error);
                                window.currentUtterance = null;
                            };
                            
                            // Starte das Sprechen
                            window.speechSynthesis.speak(utterance);
                            console.log('TTS: Spreche Text: ' + text);
                            
                            return true;
                        } catch (error) {
                            console.error('Fehler beim Sprechen:', error);
                            return false;
                        }
                    };

                    // Stoppe die Sprachausgabe
                    window.stopSpeaking = function() {
                        try {
                            if (window.speechSynthesis) {
                                window.speechSynthesis.cancel();
                                window.currentUtterance = null;
                                console.log('TTS: Sprachausgabe gestoppt');
                                return true;
                            }
                        } catch (error) {
                            console.error('Fehler beim Stoppen der Sprachausgabe:', error);
                        }
                        return false;
                    };
                ");
                
                // Auch den externen TTS-Script laden (als Backup)
                Logger.LogInformation("Loading browser TTS script as backup");
                await JSRuntimeForTts.InvokeVoidAsync("eval", 
                    "if (!document.getElementById('browser-tts-js')) {" +
                    "  var script = document.createElement('script');" +
                    "  script.id = 'browser-tts-js';" +
                    "  script.src = '_content/LocalAiDemo.Shared/browser-tts.js';" +
                    "  script.async = true;" +
                    "  script.onload = function() { " +
                    "    console.log('Browser TTS script loaded successfully'); " +
                    "  };" +
                    "  script.onerror = function() { console.error('Failed to load Browser TTS script'); };" +
                    "  document.body.appendChild(script);" +
                    "}");
                
                // Short delay to ensure script is loaded
                await Task.Delay(1000);
                
                // Create our object reference
                objRef = DotNetObjectReference.Create(this);
                  // Initialize speech recognition with our object reference
                Logger.LogInformation("Initializing speech recognition");                var speechRecognitionAvailable = await SstService.IsAvailableAsync(JSRuntimeForSst);
                if (speechRecognitionAvailable)
                {
                    await SstService.InitializeSpeechRecognitionAsync(JSRuntimeForSst, objRef);
                    Logger.LogInformation("Speech recognition initialized");
                }
                else
                {
                    Logger.LogWarning("Speech recognition not available in this browser");
                }
                
                // TTS direkt initialisieren
                try {
                    Logger.LogInformation("Explicitly initializing browser TTS");
                    await JSRuntimeForTts.InvokeVoidAsync("initBrowserTts");
                    Logger.LogInformation("Browser TTS initialized");
                    
                    // Test, ob speakText definiert ist
                    var speakTextDefined = await JSRuntimeForTts.InvokeAsync<bool>("eval", 
                        "typeof window.speakText === 'function'");
                    Logger.LogInformation("speakText function is " + (speakTextDefined ? "defined" : "NOT defined"));
                }
                catch (Exception ex) {
                    Logger.LogError(ex, "Error initializing Browser TTS: {ErrorMessage}", ex.Message);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing scripts: {ErrorMessage}", ex.Message);
            }
        }
    }
      private async Task StartRecording()
    {
        try
        {
            Logger.LogInformation("Starte Sprachaufnahme");
            isRecording = true;
            await SstService.StartSpeechRecognitionAsync(JSRuntimeForSst);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Starten der Sprachaufnahme: {ErrorMessage}", ex.Message);
        }
    }

    private async Task StopRecording()
    {
        try
        {
            if (!isRecording) return;
            
            Logger.LogInformation("Stoppe Sprachaufnahme");
            isRecording = false;
            await SstService.StopSpeechRecognitionAsync(JSRuntimeForSst);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Stoppen der Sprachaufnahme: {ErrorMessage}", ex.Message);
        }
    }
    
    [JSInvokable]
    public async Task OnSpeechRecognized(string text)
    {
        try
        {
            Logger.LogInformation("Spracherkennung erfolgreich: {Text}", text);
            recordedText = text;
            
            if (!string.IsNullOrWhiteSpace(recordedText))
            {
                // Füge die Benutzer-Nachricht zum Assistenten-Chat hinzu
                var userMessage = new ChatMessage
                {
                    Id = assistantChat.Messages.Count > 0 ? assistantChat.Messages.Max(m => m.Id) + 1 : 1,
                    Content = recordedText,
                    Timestamp = DateTime.Now,
                    IsUser = true
                };
                assistantChat.Messages.Add(userMessage);
                
                // Generiere eine Antwort vom Assistenten
                string assistantResponse = await AiAssistant.GetResponseAsync(recordedText);
                
                // Füge die Assistenten-Antwort hinzu
                var assistantMessage = new ChatMessage
                {
                    Id = assistantChat.Messages.Count > 0 ? assistantChat.Messages.Max(m => m.Id) + 1 : 1,
                    Content = assistantResponse,
                    Timestamp = DateTime.Now,
                    IsUser = false
                };
                assistantChat.Messages.Add(assistantMessage);
                
                // Spreche die Antwort mit TTS
                await SpeakAssistantResponse(assistantResponse);

                // UI aktualisieren
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler bei der Verarbeitung der erkannten Sprache: {ErrorMessage}", ex.Message);
        }
    }    private async Task SpeakAssistantResponse(string response)
    {
        try
        {
            Logger.LogInformation("Spreche Assistenten-Antwort mit TTS: {ResponseLength} Zeichen", response.Length);
              // UI-Status aktualisieren (thread-safe)
            isSpeaking = true;
            await InvokeAsync(() => StateHasChanged());
              // Verwende den injizierten TTS-Service
            if (TtsService != null)
            {                try
                {
                    // Verwende das TTS-Service Interface mit IJSRuntime
                    await TtsService.SpeakAsync(response, JSRuntimeForTts);
                    Logger.LogInformation("TTS erfolgreich gestartet für {Length} Zeichen", response.Length);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Fehler beim Sprechen mit TTS-Service: {ErrorMessage}", ex.Message);
                    
                    // Fallback zum Browser-TTS wenn der Service fehlschlägt
                    if (JSRuntimeForTts != null)
                    {
                        Logger.LogWarning("Verwende Browser-TTS als Fallback");
                        await JSRuntimeForTts.InvokeVoidAsync("eval", @"                            try {
                                if ('speechSynthesis' in window) {
                                    window.speechSynthesis.cancel();
                                    var u = new SpeechSynthesisUtterance('" + response.Replace("'", "\\'").Replace("\n", " ") + @"');
                                    u.lang = 'de-DE';
                                    window.speechSynthesis.speak(u);
                                    console.log('Fallback TTS ausgeführt');
                                }
                            } catch (e) { 
                                console.error('Fallback TTS fehlgeschlagen:', e); 
                            }
                        ");
                    }
                }
            }
            else if (JSRuntimeForTts != null)
            {
                // Fallback zum Browser-TTS wenn kein TTS-Service verfügbar ist
                Logger.LogWarning("Kein TTS-Service verfügbar, verwende Browser-TTS");
                await JSRuntimeForTts.InvokeVoidAsync("eval", @"
                    try {
                        if ('speechSynthesis' in window) {
                            window.speechSynthesis.cancel();
                            var u = new SpeechSynthesisUtterance('" + response.Replace("'", "\\'").Replace("\n", " ") + @"');
                            u.lang = 'de-DE';
                            window.speechSynthesis.speak(u);
                            console.log('Fallback TTS ausgeführt');
                        }
                    } catch (e) { 
                        console.error('Fallback TTS fehlgeschlagen:', e); 
                    }
                ");
            }
            else
            {
                Logger.LogWarning("Weder TTS-Service noch JSRuntime verfügbar für TTS");
            }
              // UI-Status zurücksetzen (mit Verzögerung, thread-safe)
            await Task.Delay(Math.Min(3000, response.Length * 40)); // ~40ms pro Zeichen, max 3 Sekunden
            isSpeaking = false;
            await InvokeAsync(() => StateHasChanged());
        }        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Sprechen der Assistenten-Antwort: {ErrorMessage}", ex.Message);
            isSpeaking = false;
            await InvokeAsync(() => StateHasChanged());
        }
    }private async Task StopTts()
    {
        try
        {
            if (isSpeaking)
            {                // Versuche zuerst den TTS-Service zu verwenden
                if (TtsService != null)
                {                    try
                    {
                        // Verwende das TTS-Service Interface mit IJSRuntime
                        await TtsService.StopSpeakingAsync(JSRuntimeForTts);
                        Logger.LogInformation("TTS-Ausgabe über Service gestoppt");
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning("Fehler beim Stoppen der TTS über Service: {Error}, versuche Fallback", ex.Message);
                        
                        // Fallback zum Browser TTS
                        if (JSRuntimeForTts != null)
                        {
                            await JSRuntimeForTts.InvokeVoidAsync("eval", "if('speechSynthesis' in window) window.speechSynthesis.cancel();");
                            Logger.LogInformation("TTS-Ausgabe über Browser gestoppt");
                        }
                    }
                }
                // Fallback zum Browser wenn kein Service verfügbar
                else if (JSRuntimeForTts != null)
                {
                    await JSRuntimeForTts.InvokeVoidAsync("eval", "if('speechSynthesis' in window) window.speechSynthesis.cancel();");
                    Logger.LogInformation("TTS-Ausgabe über Browser gestoppt");
                }
                
                isSpeaking = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler beim Stoppen der TTS-Ausgabe: {ErrorMessage}", ex.Message);
        }
    }
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            Logger.LogDebug("Home.OnInitializedAsync starting");

            // Initialize the database
            Logger.LogDebug("Initializing database...");
            await ChatDatabase.InitializeDatabaseAsync();
            Logger.LogDebug("Database initialized");

            // Load chats
            Logger.LogDebug("Loading chats...");
            chats = await ChatDatabase.GetAllChatsAsync();
            displayedChats = chats.ToList();
            Logger.LogDebug("Loaded {ChatCount} chats", chats.Count);            // Load available contacts
            Logger.LogDebug("Loading contacts...");
            availableContacts = await ChatDatabase.GetAllContactsAsync();
            Logger.LogDebug("Loaded {ContactCount} contacts", availableContacts.Count);

            // Select the first chat if available
            if (chats.Any())
            {
                selectedChatId = chats.First().Id;
                Logger.LogDebug("Selected chat ID: {ChatId}", selectedChatId);
            }

            // Get initial measurements
            Logger.LogDebug("Getting initial measurements...");
            measurements = MeasurementService.GetMeasurements();
            Logger.LogDebug("Found {MeasurementCount} measurements", measurements.Count);

            // Log measurements
            foreach (var m in measurements)
            {
                Logger.LogDebug("Measurement: {Name}={Value}{Unit}", m.Name, m.Value.ToString("F1"), m.Unit);
            }            // Subscribe to measurement updates
            Logger.LogDebug("Subscribing to measurement updates");
            MeasurementService.MeasurementsUpdated += OnMeasurementsUpdated;
            
            // Subscribe to message injection events
            Logger.LogDebug("Subscribing to message injection events");            MessageInjection.ChatNavigationRequested += OnChatNavigationRequested;
              // Run migration to add ContactId to existing chats
            Logger.LogDebug("Running chat migration...");
            // Migration methods have been removed - now handled by database initialization
            
            // Ensure chat-contact consistency for demo purposes
            Logger.LogDebug("Ensuring chat-contact consistency...");
            // Consistency check removed - now handled by database initialization
            
            // Initialize Text Generation Service
            await InitializeTextGenerationServiceAsync();
            
            Logger.LogDebug("Home.OnInitializedAsync completed");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in OnInitializedAsync: {ErrorMessage}", ex.Message);
        }
    }
    
    public void Dispose()
    {        try
        {
            // Unsubscribe from events when component is disposed
            MeasurementService.MeasurementsUpdated -= OnMeasurementsUpdated;
            MessageInjection.ChatNavigationRequested -= OnChatNavigationRequested;
            
            // Stop active TTS
            if (isSpeaking)
            {
                StopTts().ConfigureAwait(false);
            }
            
            // Clean up JS object reference
            objRef?.Dispose();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler in Dispose-Methode: {ErrorMessage}", ex.Message);
        }
    }
    
    private void OnMeasurementsUpdated(object? sender, List<Measurement> updatedMeasurements)
    {
        if (updatedMeasurements == null || updatedMeasurements.Count == 0)
        {
            Logger.LogDebug("Received empty measurements update");
            return;
        }
        
        // Update measurements with the newest data
        measurements = updatedMeasurements;
        
        // Log the new measurements
        foreach (var m in measurements)
        {
            Logger.LogDebug("Updated measurement: {Name}={Value}{Unit}", m.Name, m.Value.ToString("F1"), m.Unit);
        }
        
        // Update UI
        InvokeAsync(StateHasChanged);
    }
    
    private async Task SelectChat(int chatId)
    {
        try
        {
            Logger.LogInformation("SelectChat called with chatId={ChatId}", chatId);
            
            if (chatId <= 0)
            {
                Logger.LogWarning("Invalid chatId: {ChatId}", chatId);
                return;
            }
            
            selectedChatId = chatId;
            
            // Make sure we have the latest data
            Chat? chat = null;
            try
            {
                chat = await ChatDatabase.GetChatAsync(chatId);
                if (chat == null)
                {
                    Logger.LogWarning("ChatDatabase.GetChatAsync({ChatId}) returned null", chatId);
                    
                    // Try to use the ChatService as a fallback
                    chat = await ChatService.GetChatAsync(chatId);
                    if (chat == null)
                    {
                        Logger.LogWarning("ChatService.GetChatAsync({ChatId}) also returned null", chatId);
                    }
                    else
                    {
                        Logger.LogInformation("Retrieved chat from ChatService: {ChatId}", chat.Id);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error retrieving chat {ChatId}: {ErrorMessage}", chatId, ex.Message);
            }
            
            if (chat != null)
            {
                Logger.LogInformation("Retrieved chat: id={ChatId}, Title={Title}, Messages={Count}", 
                    chat.Id, chat.Title, chat.Messages.Count);
                    
                // Update the chat in our list
                var index = chats.FindIndex(c => c.Id == chatId);
                if (index >= 0)
                {
                    chats[index] = chat;
                    Logger.LogInformation("Updated chat in list at index {Index}", index);
                }
                else
                {
                    Logger.LogWarning("Chat {ChatId} not found in chat list!", chatId);
                    // Add it to the list as it should be there
                    chats.Insert(0, chat);
                    Logger.LogInformation("Added chat to list");
                }
                
                // Force UI update
                await InvokeAsync(StateHasChanged);
                Logger.LogInformation("UI updated after chat selection");
                
                // Force UI update for the ChatView component
                Logger.LogInformation("Forcing UI update for ChatView");
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                Logger.LogWarning("Selected chat {ChatId} not found in database", chatId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in SelectChat: {ErrorMessage}", ex.Message);
        }
    }
      private async Task ShowContactSelectModal()
    {
        // Reload contacts list before showing the modal
        Logger.LogDebug("Reloading contacts before showing modal");
        try
        {
            availableContacts = await ChatDatabase.GetAllContactsAsync();
            Logger.LogDebug("Reloaded {ContactCount} contacts", availableContacts.Count);

            if (availableContacts.Count == 0)
            {
                Logger.LogDebug("No contacts found, attempting to reinitialize database");
                await ChatDatabase.InitializeDatabaseAsync();
                availableContacts = await ChatDatabase.GetAllContactsAsync();
                Logger.LogDebug("After reinitialization: {ContactCount} contacts", availableContacts.Count);
            }
            
            // Make sure the modal exists
            if (contactSelectModal == null)
            {
                Logger.LogWarning("contactSelectModal is null!");
                return;
            }
            
            // Show the modal
            Logger.LogDebug("Showing contact select modal");
            await contactSelectModal.Show();
            
            // Force UI update
            StateHasChanged();
            
            Logger.LogDebug("Modal should now be visible");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in ShowContactSelectModal: {ErrorMessage}", ex.Message);
        }
    }
    
    private async Task OnContactSelected(Contact contact)
    {
        try
        {
            Logger.LogInformation("Home.OnContactSelected - Called with contact: {ContactName} (ID: {ContactId})", 
                contact?.Name ?? "null", contact?.Id ?? 0);
            
            if (contact == null)
            {
                Logger.LogError("Home.OnContactSelected - Received null contact!");
                return;
            }
            
            // Log the ChatService instance to see if it's properly injected
            if (ChatService == null)
            {
                Logger.LogError("ChatService is null! Service was not injected properly.");
                
                // Fall back to direct creation if ChatService is not available
                Logger.LogInformation("Falling back to direct chat creation");
                var newChat = new Chat
                {
                    Title = $"Chat with {contact.Name}",
                    CreatedAt = DateTime.Now,
                    IsActive = true,
                    ContactId = contact.Id,
                    Contact = contact,
                    Messages = new List<ChatMessage>()
                };
                
                // Add the first message
                var firstMessage = new ChatMessage
                {
                    Content = $"Hallo, ich bin {contact.Name} vom {contact.Department}. Wie kann ich dir helfen?",
                    Timestamp = DateTime.Now,
                    IsUser = false
                };
                newChat.Messages.Add(firstMessage);
                
                try
                {
                    // Save using ChatDatabase directly
                    var chatId = await ChatDatabase.SaveChatAsync(newChat);
                    newChat.Id = chatId;
                    
                    chats.Insert(0, newChat);
                    displayedChats = new List<Chat>(chats);
                    
                    selectedChatId = chatId;
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error in fallback chat creation: {ErrorMessage}", ex.Message);
                }
                
                return;
            }
            
            Logger.LogInformation("Creating new chat with contact {ContactId} ({ContactName})", contact.Id, contact.Name);
            
            try 
            {
                // Use ChatService to create a new chat with the selected contact
                var newChat = await ChatService.CreateNewChatAsync(contact);
                
                if (newChat == null)
                {
                    Logger.LogError("ChatService.CreateNewChatAsync returned null!");
                    return;
                }
                
                Logger.LogInformation("New chat created with ID: {ChatId}", newChat.Id);
                
                if (newChat.Id == 0)
                {
                    Logger.LogWarning("New chat has ID=0, which may indicate it wasn't saved correctly");
                }
                
                // Add to our list and select it
                chats.Insert(0, newChat);
                displayedChats = new List<Chat>(chats);
                
                // Set the selectedChatId directly
                selectedChatId = newChat.Id;
                
                // Force UI update first
                await InvokeAsync(StateHasChanged);
                
                // Then use SelectChat to refresh the UI with the new chat
                Logger.LogInformation("Selecting chat with ID: {ChatId}", newChat.Id);
                await SelectChat(newChat.Id);
                
                Logger.LogInformation("UI updated with new chat");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error creating chat with ChatService: {ErrorMessage}", ex.Message);
            }
        }
        catch (Exception ex)
        {            Logger.LogError(ex, "Overall error in OnContactSelected: {ErrorMessage}", ex.Message);
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OnModalCancelled()
    {
        // Nothing to do
    }

    private async Task HandleSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await PerformVectorSearch();
        }
    }
    
    private async Task PerformVectorSearch()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            // Clear search results and show all chats
            searchResults.Clear();
            displayedChats = chats.ToList();
            await InvokeAsync(StateHasChanged);
            return;
        }

        isSearching = true;
        try
        {
            Logger.LogInformation("Performing vector search for query: {Query}", searchQuery);
            
            // Use vector-based semantic search
            searchResults = await ChatService.SearchChatSegmentsAsync(searchQuery);
            
            Logger.LogInformation("Found {ResultCount} vector search results", searchResults?.Count ?? 0);
            
            // Clear displayed chats when showing search results
            displayedChats.Clear();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error performing vector search: {ErrorMessage}", ex.Message);
            searchResults.Clear();
            // Fallback to showing all chats
            displayedChats = chats.ToList();
        }
        finally
        {
            isSearching = false;
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private void ClearSearchResults()
    {
        searchResults.Clear();
        searchQuery = "";
        displayedChats = chats.ToList(); // Show all chats again
        StateHasChanged();
    }
    
    private async Task NavigateToSearchResult(ChatSegmentSearchResult result)
    {
        Logger.LogInformation("User clicked on search result for chat {ChatId} on date: {Date}", 
            result.Chat?.Id ?? 0, result.Segment.SegmentDate.ToShortDateString());
        
        // Navigate to the chat containing this result
        if (result.Chat != null)
        {
            await SelectChat(result.Chat.Id);
            
            // Clear search results to return to normal chat view
            searchResults.Clear();
            searchQuery = "";
            displayedChats = chats.ToList();
            await InvokeAsync(StateHasChanged);
        }
    }  

    private string GetChatPreview(Chat chat)
    {
        var lastMessage = chat.Messages.OrderByDescending(m => m.Timestamp).FirstOrDefault();
        return lastMessage?.Content ?? "";
    }

    // Helper method to format timestamps for display
    private string FormatTime(DateTime time)
    {
        if (time.Date == DateTime.Now.Date)
        {
            return time.ToString("HH:mm");
        }
        else if (time.Date == DateTime.Now.Date.AddDays(-1))
        {
            return "Gestern";
        }
        else
        {
            return time.ToString("dd.MM.yyyy");
        }
    }

    private string GetIconForCapability(string capability)
    {
        return capability switch
        {
            "Textgenerierung" => "bi bi-chat-dots",
            "Übersetzung" => "bi bi-translate",
            "Informationen" => "bi bi-lightbulb",
            "Code-Hilfe" => "bi bi-code-square",
            _ => "bi bi-gear"
        };
    }

    private string GetIconForMeasurement(string measurementName)
    {
        return measurementName switch
        {
            "CPU-Auslastung" => "bi bi-cpu",
            "Speichernutzung" => "bi bi-memory",
            "Netzwerkverkehr" => "bi bi-speedometer",
            "Latenz" => "bi bi-clock",
            "Temperatur" => "bi bi-thermometer-half",
            _ => "bi bi-graph-up"
        };
    }

    // Handle chat updates from ChatView component
    private async Task HandleChatUpdated(Chat updatedChat)
    {
        Logger.LogInformation("HandleChatUpdated called with chat: {ChatId}", updatedChat.Id);
        
        // Update the chat in our list
        var index = chats.FindIndex(c => c.Id == updatedChat.Id);
        if (index >= 0)
        {
            chats[index] = updatedChat;
            Logger.LogInformation("Updated chat in list at index {Index}", index);
        }
        
        // Make sure displayedChats is updated too (in case of search filtering)
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            displayedChats = chats.ToList();
        }
        else
        {
            // SearchChats();
        }
        
        // Force UI update
        await InvokeAsync(StateHasChanged);
    }

    // Handle navigation to a chat from global search results
    private async Task HandleNavigateToChat(Chat targetChat)
    {
        Logger.LogInformation("HandleNavigateToChat called with chat: {ChatId}", targetChat.Id);
          // Select the target chat
        await SelectChat(targetChat.Id);
        
        // Clear any existing search in the search box
        searchQuery = string.Empty;
        displayedChats = chats.ToList();
        
        // Force UI update
        await InvokeAsync(StateHasChanged);
    }

    private async Task InitializeTextGenerationServiceAsync()
    {
        try
        {
            Logger.LogInformation("Starte Initialisierung des TextGenerationService");
            isTextGenerationInitializing = true;
            textGenerationProgress = 0;
            textGenerationStatus = "Initialisiere KI-Modell";
            await InvokeAsync(StateHasChanged);

            // Initialisiere das TextGeneration Service mit Progress-Callback
            await TextGenerationService.InitializeAsync(progress =>
            {
                textGenerationProgress = progress;
                
                if (progress < 99)
                {
                    textGenerationStatus = "Lade KI-Modell";
                }
                else
                {
                    textGenerationStatus = "Finalisiere Initialisierung";
                }
                
                // UI Update im Hauptthread
                InvokeAsync(StateHasChanged);
            });

            // Starte den Chat
            await TextGenerationService.StartChatAsync(progress =>
            {
                textGenerationProgress = 50 + (progress * 0.5); // Start bei 50%, gehe bis 100%
                textGenerationStatus = "Initialisiere Chat-Engine";
                
                // UI Update im Hauptthread
                InvokeAsync(StateHasChanged);
            });            isTextGenerationInitializing = false;
            isTextGenerationInitialized = true;
            textGenerationProgress = 100;
            textGenerationStatus = "KI-Modell bereit";
            
            Logger.LogInformation("TextGenerationService erfolgreich initialisiert");
            await InvokeAsync(StateHasChanged);            // Füge die Willkommensnachricht zum Assistant Chat hinzu
            var welcomeMessage = new ChatMessage
            {
                Id = 1,
                Content = Constants.AgentWelcomeMessage,
                Timestamp = DateTime.Now,
                IsUser = false
            };
            assistantChat.Messages.Add(welcomeMessage);

            // UI nochmals aktualisieren um die Willkommensnachricht anzuzeigen
            await InvokeAsync(StateHasChanged);

            // Warte kurz und spreche dann die Willkommensnachricht
            // (TTS wird verzögert aufgerufen, damit das System vollständig initialisiert ist)
            _ = Task.Run(async () =>
            {
                await Task.Delay(2000); // 2 Sekunden warten
                try
                {
                    Logger.LogInformation("Spreche AI Assistant Willkommensnachricht (verzögert)");
                    await SpeakAssistantResponse(Constants.AgentWelcomeMessage);
                }
                catch (Exception ttsEx)
                {
                    Logger.LogError(ttsEx, "Fehler beim Sprechen der Willkommensnachricht: {ErrorMessage}", ttsEx.Message);
                }
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fehler bei der Initialisierung des TextGenerationService: {ErrorMessage}", ex.Message);
            isTextGenerationInitializing = false;
            isTextGenerationInitialized = false;
            textGenerationStatus = "Fehler bei KI-Initialisierung";
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Event-Handler für Chat-Navigation-Anfragen vom MessageInjectionService
    /// </summary>
    private async void OnChatNavigationRequested(object? sender, ChatNavigationEventArgs e)
    {
        try
        {
            Logger.LogInformation("Chat navigation requested for contact {ContactName} (ID: {ContactId})", 
                e.ContactName ?? "Unknown", e.ContactId);            // Find existing chat for this contact (using getAllChats and filtering)
            var allChats = await ChatDatabase.GetAllChatsAsync();
            var existingChat = allChats.FirstOrDefault(c => c.ContactId == e.ContactId);
            
            if (existingChat != null)
            {
                Logger.LogInformation("Found existing chat {ChatId} for contact {ContactId}", existingChat.Id, e.ContactId);
                
                // Zu diesem Chat navigieren
                await SelectChat(existingChat.Id);
            }
            else
            {
                Logger.LogInformation("No existing chat found for contact {ContactId}, creating new one", e.ContactId);
                  // Create new chat for this contact
                var contact = await ChatDatabase.GetContactAsync(e.ContactId);
                if (contact != null)
                {
                    var newChat = await ChatService.CreateNewChatAsync(contact);
                    if (newChat != null)
                    {
                        // Update chat list
                        chats = await ChatDatabase.GetAllChatsAsync();
                        displayedChats = chats.ToList();
                        
                        // Navigate to the new chat
                        await SelectChat(newChat.Id);
                    }
                    else
                    {
                        Logger.LogError("Failed to create chat for contact {ContactId}", e.ContactId);
                    }
                }
                else
                {
                    Logger.LogError("Contact {ContactId} not found", e.ContactId);
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during chat navigation for contact {ContactId}: {ErrorMessage}", 
                e.ContactId, ex.Message);
        }
    }
}
